{
  "id": "bash",
  "title": "Bash",
  "intro": "This is a quick reference cheat sheet to getting started with linux bash shell scripting.",
  "tags": [
    "shell",
    "sh",
    "echo",
    "script",
    "linux"
  ],
  "categories": [
    "Programming",
    "Operating System"
  ],
  "background": "bg-[#3e4548]",
  "content": "## Getting Started\n\n### hello.sh\n\n```bash\n#!/bin/bash\n\nVAR=\"world\"\necho \"Hello $VAR!\" # => Hello world!\n```\n\nExecute the script\n\n```shell script\n$ bash hello.sh\n```\n\n### Variables\n\n```bash\nNAME=\"John\"\n\necho ${NAME}    # => John (Variables)\necho $NAME      # => John (Variables)\necho \"$NAME\"    # => John (Variables)\necho '$NAME'    # => $NAME (Exact string)\necho \"${NAME}!\" # => John! (Variables)\n\nNAME = \"John\"   # => Error (about space)\n```\n\n### Comments\n\n```bash\n# This is an inline Bash comment.\n```\n\n```bash\n: '\nThis is a\nvery neat comment\nin bash\n'\n```\n\nMulti-line comments use `:'` to open and `'` to close\n\n### Arguments {.row-span-2}\n\n| Expression  | Description                           |\n| ----------- | ------------------------------------- |\n| `$1` â€¦ `$9` | Parameter 1 ... 9                     |\n| `$0`        | Name of the script itself             |\n| `$1`        | First argument                        |\n| `${10}`     | Positional parameter 10               |\n| `$#`        | Number of arguments                   |\n| `$$`        | Process id of the shell               |\n| `$*`        | All arguments                         |\n| `$@`        | All arguments, starting from first    |\n| `$-`        | Current options                       |\n| `$_`        | Last argument of the previous command |\n\nSee: [Special parameters](http://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables)\n\n### Functions\n\n```bash\nget_name() {\n    echo \"John\"\n}\n\necho \"You are $(get_name)\"\n```\n\nSee: [Functions](#bash-functions)\n\n### Conditionals {#conditionals-example}\n\n```bash\nif [[ -z \"$string\" ]]; then\n    echo \"String is empty\"\nelif [[ -n \"$string\" ]]; then\n    echo \"String is not empty\"\nfi\n```\n\nSee: [Conditionals](#bash-conditionals)\n\n### Brace expansion\n\n```bash\necho {A,B}.js\n```\n\n---\n\n| Expression | Description         |\n| ---------- | ------------------- |\n| `{A,B}`    | Same as `A B`       |\n| `{A,B}.js` | Same as `A.js B.js` |\n| `{1..5}`   | Same as `1 2 3 4 5` |\n\nSee: [Brace expansion](http://wiki.bash-hackers.org/syntax/expansion/brace)\n\n### Shell execution\n\n```bash\n# => I'm in /path/of/current\necho \"I'm in $(PWD)\"\n\n# Same as:\necho \"I'm in `pwd`\"\n```\n\nSee: [Command substitution](http://wiki.bash-hackers.org/syntax/expansion/cmdsubst)\n\n## Bash Parameter expansions\n\n### Syntax {.row-span-2}\n\n| Code              | Description         |\n| ----------------- | ------------------- |\n| `${FOO%suffix}`   | Remove suffix       |\n| `${FOO#prefix}`   | Remove prefix       |\n| `${FOO%%suffix}`  | Remove long suffix  |\n| `${FOO##prefix}`  | Remove long prefix  |\n| `${FOO/from/to}`  | Replace first match |\n| `${FOO//from/to}` | Replace all         |\n| `${FOO/%from/to}` | Replace suffix      |\n| `${FOO/#from/to}` | Replace prefix      |\n\n#### Substrings\n\n| Expression      | Description                    |\n| --------------- | ------------------------------ |\n| `${FOO:0:3}`    | Substring _(position, length)_ |\n| `${FOO:(-3):3}` | Substring from the right       |\n\n#### Length\n\n| Expression | Description      |\n| ---------- | ---------------- |\n| `${#FOO}`  | Length of `$FOO` |\n\n#### Default values\n\n| Expression        | Description                              |\n| ----------------- | ---------------------------------------- |\n| `${FOO:-val}`     | `$FOO`, or `val` if unset                |\n| `${FOO:=val}`     | Set `$FOO` to `val` if unset             |\n| `${FOO:+val}`     | `val` if `$FOO` is set                   |\n| `${FOO:?message}` | Show message and exit if `$FOO` is unset |\n\n### Substitution\n\n```bash\necho ${food:-Cake}  #=> $food or \"Cake\"\n```\n\n```bash\nSTR=\"/path/to/foo.cpp\"\necho ${STR%.cpp}    # /path/to/foo\necho ${STR%.cpp}.o  # /path/to/foo.o\necho ${STR%/*}      # /path/to\n\necho ${STR##*.}     # cpp (extension)\necho ${STR##*/}     # foo.cpp (basepath)\n\necho ${STR#*/}      # path/to/foo.cpp\necho ${STR##*/}     # foo.cpp\n\necho ${STR/foo/bar} # /path/to/bar.cpp\n```\n\n### Slicing\n\n```bash\nname=\"John\"\necho ${name}           # => John\necho ${name:0:2}       # => Jo\necho ${name::2}        # => Jo\necho ${name::-1}       # => Joh\necho ${name:(-1)}      # => n\necho ${name:(-2)}      # => hn\necho ${name:(-2):2}    # => hn\n\nlength=2\necho ${name:0:length}  # => Jo\n```\n\nSee: [Parameter expansion](http://wiki.bash-hackers.org/syntax/pe)\n\n### basepath & dirpath\n\n```bash\nSRC=\"/path/to/foo.cpp\"\n```\n\n```bash\nBASEPATH=${SRC##*/}\necho $BASEPATH  # => \"foo.cpp\"\n\n\nDIRPATH=${SRC%$BASEPATH}\necho $DIRPATH   # => \"/path/to/\"\n```\n\n### Transform\n\n```bash\nSTR=\"HELLO WORLD!\"\necho ${STR,}   # => hELLO WORLD!\necho ${STR,,}  # => hello world!\n\nSTR=\"hello world!\"\necho ${STR^}   # => Hello world!\necho ${STR^^}  # => HELLO WORLD!\n\nARR=(hello World)\necho \"${ARR[@],}\" # => hello world\necho \"${ARR[@]^}\" # => Hello World\n```\n\n## Bash Arrays\n\n### Defining arrays\n\n```bash\nFruits=('Apple' 'Banana' 'Orange')\n\nFruits[0]=\"Apple\"\nFruits[1]=\"Banana\"\nFruits[2]=\"Orange\"\n\nARRAY1=(foo{1..2}) # => foo1 foo2\nARRAY2=({A..D})    # => A B C D\n\n# Merge => foo1 foo2 A B C D\nARRAY3=(${ARRAY1[@]} ${ARRAY2[@]})\n\n# declare construct\ndeclare -a Numbers=(1 2 3)\nNumbers+=(4 5) # Append => 1 2 3 4 5\n```\n\n### Indexing\n\n| -                  | -             |\n| ------------------ | ------------- |\n| `${Fruits[0]}`     | First element |\n| `${Fruits[-1]}`    | Last element  |\n| `${Fruits[*]}`     | All elements  |\n| `${Fruits[@]}`     | All elements  |\n| `${#Fruits[@]}`    | Number of all |\n| `${#Fruits}`       | Length of 1st |\n| `${#Fruits[3]}`    | Length of nth |\n| `${Fruits[@]:3:2}` | Range         |\n| `${!Fruits[@]}`    | Keys of all   |\n\n### Iteration\n\n```bash\nFruits=('Apple' 'Banana' 'Orange')\n\nfor e in \"${Fruits[@]}\"; do\n    echo $e\ndone\n```\n\n#### With index\n\n```bash\nfor i in \"${!Fruits[@]}\"; do\n  printf \"%s\\t%s\\n\" \"$i\" \"${Fruits[$i]}\"\ndone\n\n```\n\n### Operations {.col-span-2}\n\n```bash\nFruits=(\"${Fruits[@]}\" \"Watermelon\")     # Push\nFruits+=('Watermelon')                   # Also Push\nFruits=( ${Fruits[@]/Ap*/} )             # Remove by regex match\nunset Fruits[2]                          # Remove one item\nFruits=(\"${Fruits[@]}\")                  # Duplicate\nFruits=(\"${Fruits[@]}\" \"${Veggies[@]}\")  # Concatenate\nlines=(`cat \"logfile\"`)                  # Read from file\n```\n\n### Arrays as arguments\n\n```bash\nfunction extract()\n{\n    local -n myarray=$1\n    local idx=$2\n    echo \"${myarray[$idx]}\"\n}\nFruits=('Apple' 'Banana' 'Orange')\nextract Fruits 2     # => Orangle\n```\n\n## Bash Dictionaries\n\n### Defining\n\n```bash\ndeclare -A sounds\n```\n\n```bash\nsounds[dog]=\"bark\"\nsounds[cow]=\"moo\"\nsounds[bird]=\"tweet\"\nsounds[wolf]=\"howl\"\n```\n\n### Working with dictionaries\n\n```bash\necho ${sounds[dog]} # Dog's sound\necho ${sounds[@]}   # All values\necho ${!sounds[@]}  # All keys\necho ${#sounds[@]}  # Number of elements\nunset sounds[dog]   # Delete dog\n```\n\n### Iteration\n\n```bash\nfor val in \"${sounds[@]}\"; do\n    echo $val\ndone\n```\n\n---\n\n```bash\nfor key in \"${!sounds[@]}\"; do\n    echo $key\ndone\n```\n\n## Bash Conditionals\n\n### Integer conditions\n\n| Condition           | Description                                 |\n| ------------------- | ------------------------------------------- |\n| `[[ NUM -eq NUM ]]` | <yel>Eq</yel>ual                            |\n| `[[ NUM -ne NUM ]]` | <yel>N</yel>ot <yel>e</yel>qual             |\n| `[[ NUM -lt NUM ]]` | <yel>L</yel>ess <yel>t</yel>han             |\n| `[[ NUM -le NUM ]]` | <yel>L</yel>ess than or <yel>e</yel>qual    |\n| `[[ NUM -gt NUM ]]` | <yel>G</yel>reater <yel>t</yel>han          |\n| `[[ NUM -ge NUM ]]` | <yel>G</yel>reater than or <yel>e</yel>qual |\n| `(( NUM < NUM ))`   | Less than                                   |\n| `(( NUM <= NUM ))`  | Less than or equal                          |\n| `(( NUM > NUM ))`   | Greater than                                |\n| `(( NUM >= NUM ))`  | Greater than or equal                       |\n\n### String conditions\n\n| Condition          | Description                 |\n| ------------------ | --------------------------- |\n| `[[ -z STR ]]`     | Empty string                |\n| `[[ -n STR ]]`     | <yel>N</yel>ot empty string |\n| `[[ STR == STR ]]` | Equal                       |\n| `[[ STR = STR ]]`  | Equal (Same above)          |\n| `[[ STR < STR ]]`  | Less than _(ASCII)_         |\n| `[[ STR > STR ]]`  | Greater than _(ASCII)_      |\n| `[[ STR != STR ]]` | Not Equal                   |\n| `[[ STR =~ STR ]]` | Regexp                      |\n\n### Example {.row-span-3}\n\n#### String\n\n```bash\nif [[ -z \"$string\" ]]; then\n    echo \"String is empty\"\nelif [[ -n \"$string\" ]]; then\n    echo \"String is not empty\"\nelse\n    echo \"This never happens\"\nfi\n```\n\n#### Combinations\n\n```bash\nif [[ X && Y ]]; then\n    ...\nfi\n```\n\n#### Equal\n\n```bash\nif [[ \"$A\" == \"$B\" ]]; then\n    ...\nfi\n```\n\n#### Regex\n\n```bash\nif [[ '1. abc' =~ ([a-z]+) ]]; then\n    echo ${BASH_REMATCH[1]}\nfi\n```\n\n#### Smaller\n\n```bash\nif (( $a < $b )); then\n   echo \"$a is smaller than $b\"\nfi\n```\n\n#### Exists\n\n```bash\nif [[ -e \"file.txt\" ]]; then\n    echo \"file exists\"\nfi\n```\n\n### File conditions {.row-span-2}\n\n| Condition         | Description                            |\n| ----------------- | -------------------------------------- |\n| `[[ -e FILE ]]`   | <yel>E</yel>xists                      |\n| `[[ -d FILE ]]`   | <yel>D</yel>irectory                   |\n| `[[ -f FILE ]]`   | <yel>F</yel>ile                        |\n| `[[ -h FILE ]]`   | Symlink                                |\n| `[[ -s FILE ]]`   | Size is > 0 bytes                      |\n| `[[ -r FILE ]]`   | <yel>R</yel>eadable                    |\n| `[[ -w FILE ]]`   | <yel>W</yel>ritable                    |\n| `[[ -x FILE ]]`   | Executable                             |\n| `[[ f1 -nt f2 ]]` | f1 <yel>n</yel>ewer <yel>t</yel>han f2 |\n| `[[ f1 -ot f2 ]]` | f2 <yel>o</yel>lder <yel>t</yel>han f1 |\n| `[[ f1 -ef f2 ]]` | Same files                             |\n\n### More conditions\n\n| Condition            | Description          |\n| -------------------- | -------------------- | ----- | --- |\n| `[[ -o noclobber ]]` | If OPTION is enabled |\n| `[[ ! EXPR ]]`       | Not                  |\n| `[[ X && Y ]]`       | And                  |\n| `[[ X                |                      | Y ]]` | Or  |\n\n### logical and, or\n\n```bash\nif [ \"$1\" = 'y' -a $2 -gt 0 ]; then\n    echo \"yes\"\nfi\n\nif [ \"$1\" = 'n' -o $2 -lt 0 ]; then\n    echo \"no\"\nfi\n```\n\n## Bash Loops\n\n### Basic for loop\n\n```bash\nfor i in /etc/rc.*; do\n    echo $i\ndone\n```\n\n### C-like for loop\n\n```bash\nfor ((i = 0 ; i < 100 ; i++)); do\n    echo $i\ndone\n```\n\n### Ranges {.row-span-2}\n\n```bash\nfor i in {1..5}; do\n    echo \"Welcome $i\"\ndone\n```\n\n#### With step size\n\n```bash\nfor i in {5..50..5}; do\n    echo \"Welcome $i\"\ndone\n```\n\n### Continue\n\n```bash {data=3,5}\nfor number in $(seq 1 3); do\n    if [[ $number == 2 ]]; then\n        continue;\n    fi\n    echo \"$number\"\ndone\n```\n\n### Break\n\n```bash\nfor number in $(seq 1 3); do\n    if [[ $number == 2 ]]; then\n        # Skip entire rest of loop.\n        break;\n    fi\n    # This will only print 1\n    echo \"$number\"\ndone\n```\n\n### Until\n\n```bash\ncount=0\nuntil [ $count -gt 10 ]; do\n    echo \"$count\"\n    ((count++))\ndone\n```\n\n### While with increment\n\n```bash\ni=1\nwhile [[ $i -lt 4 ]]; do\n    echo \"Number: $i\"\n    ((i++))\ndone\n```\n\n### While with decrement\n\n```bash\ni=3\nwhile [[ $i -gt 0 ]]; do\n    echo \"Number: $i\"\n    ((i--))\ndone\n```\n\n#### Combined with test\n\n```bash\ni=3\nwhile ((i--)); do\n    echo \"Number: $i\"\ndone\n```\n\n### Forever\n\n```bash\nwhile true; do\n    # here is some code.\ndone\n```\n\n### Forever (shorthand)\n\n```bash\nwhile :; do\n    # here is some code.\ndone\n```\n\n### Reading lines\n\n```bash\nwhile read line; do\n    echo $line\ndone < file.txt\n```\n\n## Bash Functions\n\n### Defining functions\n\n```bash\nmyfunc() {\n    echo \"hello $1\"\n}\n```\n\n```bash\n# Same as above (alternate syntax)\nfunction myfunc() {\n    echo \"hello $1\"\n}\n```\n\n```bash\nmyfunc \"John\"\n```\n\n### Returning values\n\n```bash\nmyfunc() {\n    local myresult='some value'\n    echo $myresult\n}\n```\n\n```bash\nresult=\"$(myfunc)\"\n```\n\n### Raising errors\n\n```bash\nmyfunc() {\n    return 1\n}\n```\n\n```bash\nif myfunc; then\n    echo \"success\"\nelse\n    echo \"failure\"\nfi\n```\n\n## Bash Options {.cols-2}\n\n### Options\n\n```bash\n# Avoid overlay files\n# (echo \"hi\" > foo)\nset -o noclobber\n\n# Used to exit upon error\n# avoiding cascading errors\nset -o errexit\n\n# Unveils hidden failures\nset -o pipefail\n\n# Exposes unset variables\nset -o nounset\n```\n\n### Glob options\n\n```bash\n# Non-matching globs are removed\n# ('*.foo' => '')\nshopt -s nullglob\n\n# Non-matching globs throw errors\nshopt -s failglob\n\n# Case insensitive globs\nshopt -s nocaseglob\n\n# Wildcards match dotfiles\n# (\"*.sh\" => \".foo.sh\")\nshopt -s dotglob\n\n# Allow ** for recursive matches\n# ('lib/**/*.rb' => 'lib/a/b/c.rb')\nshopt -s globstar\n```\n\n## Bash History {.cols-2}\n\n### Commands\n\n| Command               | Description                               |\n| --------------------- | ----------------------------------------- |\n| `history`             | Show history                              |\n| `sudo !!`             | Run the previous command with sudo        |\n| `shopt -s histverify` | Don't execute expanded result immediately |\n\n### Expansions\n\n| Expression   | Description                                          |\n| ------------ | ---------------------------------------------------- |\n| `!$`         | Expand last parameter of most recent command         |\n| `!*`         | Expand all parameters of most recent command         |\n| `!-n`        | Expand `n`th most recent command                     |\n| `!n`         | Expand `n`th command in history                      |\n| `!<command>` | Expand most recent invocation of command `<command>` |\n\n### Operations\n\n| Code                 | Description                                                           |\n| -------------------- | --------------------------------------------------------------------- |\n| `!!`                 | Execute last command again                                            |\n| `!!:s/<FROM>/<TO>/`  | Replace first occurrence of `<FROM>` to `<TO>` in most recent command |\n| `!!:gs/<FROM>/<TO>/` | Replace all occurrences of `<FROM>` to `<TO>` in most recent command  |\n| `!$:t`               | Expand only basename from last parameter of most recent command       |\n| `!$:h`               | Expand only directory from last parameter of most recent command      |\n\n`!!` and `!$` can be replaced with any valid expansion.\n\n### Slices\n\n| Code     | Description                                                                              |\n| -------- | ---------------------------------------------------------------------------------------- |\n| `!!:n`   | Expand only `n`th token from most recent command (command is `0`; first argument is `1`) |\n| `!^`     | Expand first argument from most recent command                                           |\n| `!$`     | Expand last token from most recent command                                               |\n| `!!:n-m` | Expand range of tokens from most recent command                                          |\n| `!!:n-$` | Expand `n`th token to last from most recent command                                      |\n\n`!!` can be replaced with any valid expansion i.e. `!cat`, `!-2`, `!42`, etc.\n\n## Miscellaneous\n\n### Numeric calculations\n\n```bash\n$((a + 200))      # Add 200 to $a\n```\n\n```bash\n$(($RANDOM%200))  # Random number 0..199\n```\n\n### Subshells\n\n```bash\n(cd somedir; echo \"I'm now in $PWD\")\npwd # still in first directory\n```\n\n### Inspecting commands\n\n```bash\ncommand -V cd\n#=> \"cd is a function/alias/whatever\"\n```\n\n### Redirection {.row-span-2 .col-span-2}\n\n```bash\npython hello.py > output.txt   # stdout to (file)\npython hello.py >> output.txt  # stdout to (file), append\npython hello.py 2> error.log   # stderr to (file)\npython hello.py 2>&1           # stderr to stdout\npython hello.py 2>/dev/null    # stderr to (null)\npython hello.py &>/dev/null    # stdout and stderr to (null)\n```\n\n```bash\npython hello.py < foo.txt      # feed foo.txt to stdin for python\n```\n\n### Source relative\n\n```bash\nsource \"${0%/*}/../share/foo.sh\"\n```\n\n### Directory of script\n\n```bash\nDIR=\"${0%/*}\"\n```\n\n### Case/switch\n\n```bash\ncase \"$1\" in\n    start | up)\n    vagrant up\n    ;;\n\n    *)\n    echo \"Usage: $0 {start|stop|ssh}\"\n    ;;\nesac\n```\n\n### Trap errors {.col-span-2}\n\n```bash\ntrap 'echo Error at about $LINENO' ERR\n```\n\nor\n\n```bash\ntraperr() {\n    echo \"ERROR: ${BASH_SOURCE[1]} at about ${BASH_LINENO[0]}\"\n}\n\nset -o errtrace\ntrap traperr ERR\n```\n\n### printf\n\n```bash\nprintf \"Hello %s, I'm %s\" Sven Olga\n#=> \"Hello Sven, I'm Olga\n\nprintf \"1 + 1 = %d\" 2\n#=> \"1 + 1 = 2\"\n\nprintf \"Print a float: %f\" 2\n#=> \"Print a float: 2.000000\"\n```\n\n### Getting options {.col-span-2}\n\n```bash\nwhile [[ \"$1\" =~ ^- && ! \"$1\" == \"--\" ]]; do case $1 in\n    -V | --version )\n    echo $version\n    exit\n    ;;\n    -s | --string )\n    shift; string=$1\n    ;;\n    -f | --flag )\n    flag=1\n    ;;\nesac; shift; done\nif [[ \"$1\" == '--' ]]; then shift; fi\n```\n\n### Check for command's result {.col-span-2}\n\n```bash\nif ping -c 1 google.com; then\n    echo \"It appears you have a working internet connection\"\nfi\n```\n\n### Special variables {.row-span-2}\n\n| Expression | Description                  |\n| ---------- | ---------------------------- |\n| `$?`       | Exit status of last task     |\n| `$!`       | PID of last background task  |\n| `$$`       | PID of shell                 |\n| `$0`       | Filename of the shell script |\n\nSee [Special parameters](http://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables).\n\n### Grep check {.col-span-2}\n\n```bash\nif grep -q 'foo' ~/.bash_history; then\n    echo \"You appear to have typed 'foo' in the past\"\nfi\n```\n\n### Backslash escapes {.row-span-2}\n\n- &nbsp;\n- \\!\n- \\\"\n- \\#\n- \\&\n- \\'\n- \\(\n- \\)\n- \\,\n- \\;\n- \\<\n- \\>\n- \\[\n- \\|\n- \\\\\n- \\]\n- \\^\n- \\{\n- \\}\n- \\`\n- \\$\n- \\*\n- \\?\n\n{.cols-4 .marker-none}\n\nEscape these special characters with `\\`\n\n### Heredoc\n\n```sh\ncat <<END\nhello world\nEND\n```\n\n### Go to previous directory\n\n```bash\npwd # /home/user/foo\ncd bar/\npwd # /home/user/foo/bar\ncd -\npwd # /home/user/foo\n```\n\n### Reading input\n\n```bash\necho -n \"Proceed? [y/n]: \"\nread ans\necho $ans\n```\n\n```bash\nread -n 1 ans    # Just one character\n```\n\n### Conditional execution\n\n```bash\ngit commit && git push\ngit commit || echo \"Commit failed\"\n```\n\n### Strict mode\n\n```bash\nset -euo pipefail\nIFS=$'\\n\\t'\n```\n\nSee: [Unofficial bash strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/)\n\n### Optional arguments\n\n```bash\nargs=(\"$@\")\nargs+=(foo)\nargs+=(bar)\necho \"${args[@]}\"\n```\n\nPut the arguments into an array and then append\n\n## Also see {.cols-1}\n\n- [Devhints](https://devhints.io/bash) _(devhints.io)_\n- [Bash-hackers wiki](http://wiki.bash-hackers.org/) _(bash-hackers.org)_\n- [Shell vars](http://wiki.bash-hackers.org/syntax/shellvars) _(bash-hackers.org)_\n- [Learn bash in y minutes](https://learnxinyminutes.com/docs/bash/) _(learnxinyminutes.com)_\n- [Bash Guide](http://mywiki.wooledge.org/BashGuide) _(mywiki.wooledge.org)_\n- [ShellCheck](https://www.shellcheck.net/) _(shellcheck.net)_\n- [shell - Standard Shell](https://devmanual.gentoo.org/tools-reference/bash/index.html) _(devmanual.gentoo.org)_\n"
}