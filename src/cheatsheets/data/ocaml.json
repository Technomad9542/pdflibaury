{
  "id": "ocaml",
  "title": "OCaml",
  "intro": "|\nThe [OCaml](https://www.ocaml.org/) cheat sheet is a one-page reference sheet for the OCaml programming language.",
  "tags": [
    "scientific",
    "functional"
  ],
  "categories": [
    "Programming"
  ],
  "background": "bg-[#ec670f]",
  "content": "## Getting Started\n\n### hello.ml\n\n```ml\nlet () =\n  let message = \"Hello, World!\" in\n  Printf.printf \"%s\\n\" message\n```\n\n#### Compile and Run\n\n```bash\n$ ocamlc -o hello.byte hello.ml\n$ ./hello.byte\n```\n\n#### Build and Run with Dune\n\n```bash\n$ dune build hello.exe\n$ _build/default/hello.exe\n\n# you can also just run\n$ dune exec ./hello.exe\n```\n\nSee the [dune](https://dune.build/) documentation for more info.\n\n### Imports\n\nInstall modules with opam\n\n```bash\n$ opam install hex\n```\n\n#### Global Open\n\n```ml\nopen Hex\n```\n\n#### Local Open\n\n```ml\nHex.of_string \"hex string\"\n\nlet open Hex in\n  of_string \"to hex\"\n```\n\n### Comments\n\n#### Line & Block Comments\n\n```ml\n(* A single line comment *)\n\n(* A multi-line comment\n* where we want to explain\n* something complex *)\n\n(* Outer comment\n   (* Nested comment *)\n   End of outer comment *)\n```\n\n#### Documentation Comments\n\n```ml\nval sum : int -> int -> int\n(** [sum x y] returns the sum\n of two integers [x] and [y] *)\n```\n\n## Data Types\n\n### Predefined Types\n\n#### Unit\n\nNote: `#` Indicates execution at the toplevel followed by the output\n\n```ml\n# ();; (* equivalent to void in C *)\n- : unit = ()\n```\n\n#### Basic Types\n\n```ml\n# 5 ;; (* integer *)\n- : int = 5\n\n# 3.14 ;;  (* float *)\n- : float = 3.14\n\n# true ;; (* bool *)\n- : bool = true\n\n# false ;;\n- : bool = false\n\n# 'a' ;; (* char *)\n- : char = 'a'\n\n# \"a string\" ;; (* string *)\n- : string = \"a string\"\n\n# String.to_bytes \"hello\" ;; (* bytes *)\n- : bytes = Bytes.of_string \"hello\"\n\n# (3, 5);; (* tuple *)\n- : int * int = (3, 5)\n\n# ref 0;; (* reference *)\n- : int ref = {contents = 0}\n```\n\n#### Options & Results\n\n```ml\n# Some 42;;\n- : int option = Some 42\n\n# Ok 42;;\n- : (int, 'a) result = Ok 42\n\n# Error \"404\";;\n- : ('a, int) result = Error 404\n```\n\n### Arrays & Lists\n\n#### Arrays\n\n```ml\n# [|0; 1; 2; 3|];; (* create an array *)\n- : int array = [|0; 1; 2; 3|]\n\n# [|'u'; 's'; 'c'|].(1);; (* array access *)\n- char = 's'\n```\n\nArrays are mutable\n\n```ml\nlet scores = [|97; 85; 99|];;\n- : int array = [|97; 85; 99|]\n\n# scores.(2) <- 89;; (* update an element *)\n- unit = ()\n\n# scores;;\n- : int array = [|97; 85; 89|]\n```\n\n#### Lists\n\n```ml\n# [1; 2; 3];;\n- : int list = [1; 2; 3;]\n\n# [\"a\"; \"str\"; \"lst\"];;\n- : string list = [\"a\"; \"str\"; \"lst\"]\n```\n\nLists are immutable\n\n```ml\n# let lst = [1; 2; 3];;\n- : int list = [1; 2; 3]\n\n# let new_lst =  0 :: lst;; (* prepend to a new list *)\n- : int list = [0; 1; 2; 3]\n\n# new_lst @ [4;5;6];; (* combine two lists *)\n- : int list = [0; 1; 2; 3; 4; 5; 6]\n```\n\n### User-Defined Types\n\n#### Records\n\nBundle related data\n\n```ml\ntype person = {\n  name: string;\n  age: int\n}\n\n# let zeno = {name = \"Zeno\"; age = 30};;\nval zeno : person = {name = \"Zeno\"; age = 30}\n```\n\n#### Variants\n\nSeveral different, but related types\n\n```ml\ntype shape =\n  | Circle of float\n  | Rectangle of float * float\n\n# let my_shape = Circle 5.0;;\n- : shape = Circle 5.\n```\n\n#### Aliases\n\nProvide meaningful name to complex or commonly used types\n\n```ml\ntype point = float * float\n\n# let origin: point = (0.0, 0.0);;\nval origin : point = (0., 0.)\n```\n\n## Functions\n\n### Functions\n\n#### Single parameter\n\n```ml\nlet add_one x =\n  let result = x + 1 in\n  result\n\n# add_one 1;;\n- : int = 2\n```\n\n#### Multiple parameters\n\n```ml\nlet sum x y =\n  let result = x + y in\n  result\n\n# sum 1 2;;\n- : int = 3\n```\n\n#### Tuple parameter\n\n```ml\nlet str_concat (x, y) =\n  x ^ \" \" ^ y\n\n# str_concat (\"Hello\", \"OCaml\") ;;\n- : string = \"Hello Ocaml\"\n```\n\n### Recursive Functions\n\n#### rec keyword\n\nAll recusive functions use the rec keyword\n\n```ml\nlet rec factorial n =\n  if n < 1 then 1 else n * factorial (n - 1)\n```\n\nThe above can cause stackoverflow.\n\n#### Tail Recursion\n\nMakes use of a helper function and the acc argument.\n\n```ml\nlet rec factorial_helper n acc =\n  if n = 0 then acc\n  else factorial_helper (n - 1) (n * acc)\n```\n\nNotice the last call is the recursive function.\n\n```ml\nlet factorial n = factorial_helper n 1\n```\n\n### Chaining\n\n#### Application Operator\n\nRead from right to left, the first operation is `sum 2 3`\n\n```ml\n(* find log(2 + 3) *)\n# log @@ float_of_int @@ sum 2 3 ;;\n- : float = 1.609...\n```\n\n#### Pipeline\n\n```ml\n(* find log((x + y)!) *)\n# sum 2 3\n  |> factorial\n  |> float_of_int\n  |> log ;;\n- : float = 4.787...\n```\n\n`|>` takes the output of the function and passes it as input to the next function in the pipeline\n\n## Control Flow\n\n### If Statements\n\n#### If Statement\n\n```ml\nlet is_pos x =\n  if x > 0 then \"positive\" else \"negative\"\n```\n\n#### If else if\n\n```ml\nlet f x =\n  if x > 3 then \"gt 3\"\n  else if x < 3 then \"lt 3\"\n  else \"eq 3\"\n```\n\n#### Pattern Matching\n\n```ml\nlet is_pos x =\n  match x > 0 with\n  | true  -> \"positive\"\n  | false -> \"negative\"\n```\n\n### Loops\n\n#### For loop\n\n```ml\nfor i = 1 to 5 do\n  print_int i\ndone\n```\n\n#### While loop\n\nNotice the `ref` is needed to have the while condition eventually become false.\n\n```ml\nlet i = ref 0 in\n  while !i < 5 do\n    print_int !i;\n    i := !i + 1\n  done\n```\n\n### Operators\n\n#### Comparison Operators\n\n```ml\n=         (* equal to *)\n<>        (* not equal to *)\n>         (* greater than *)\n<         (* less than *)\n>=        (* greater than or eq to *)\n<=        (* less than or eq to *)\n```\n\n#### Arithmatic Operators\n\n```ml\n(* int operator   float operator *)\n+                 +.  (* addition *)\n-                 -.  (* subtraction *)\n*                 *.  (* multiplication *)\n/                 /.  (* division *)\n                  **  (* power *)\n```\n\n## Useful Tools\n\n### List\n\n#### Searching & Filtering\n\n```ml\n# let lst = [1; 2; 3];;\nval lst : int list = [1; 2; 3]\n\n# List.filter (fun x -> x mod 2 = 0) lst;;\n- : int list = [2]\n\n# List.find (fun x -> x = 4) lst;;\nException: Not_found\n\n# List.sort compare [2; 1; 3];;\n- : int list = [1; 2; 3]\n```\n\n#### Applying Transformations\n\n```ml\n(* Loop over list and apply fun f *)\nList.iter f lst\n\n(* map a function to each elem *)\n(* Ex. double each element x in lst *)\nList.map (fun x -> x + x) lst\n\n(* Apply an operator between elements *)\n(* Ex. 1 + 2 + 3 *)\nList.fold_left (+) 0 lst\n```\n\n### Associaton Lists\n\n#### Definition and Access\n\n```ml\nlet scores =\n  [(\"math\", 91); (\"phil\", 89); (\"stats\", 94)]\n\n# List.assoc \"stats\" scores;;\n- : int = 94\n\n# List.mem_assoc \"math\" scores;;\n- : bool = true\n```\n\n#### Split and Combine\n\n```ml\n# List.split scores;;\n- : string list * int list = ([\"math\"; \"phil\"; \"stats\"], [91; 89; 94])\n\n# List.combine [1;2;3] [4; 5; 6];;\n- : (int * int) list = [(1, 4); (2, 5); (3, 6)]\n```\n\nAssociation lists are similar to dictionaries or hashmaps\n\n### Hash Tables\n\nHash Tables are mutable.\n\n#### Initialize & Add Data\n\n```ml\n\n# let my_htable = Hashtbl.create 3;;\nval my_htable : ('_weak1, '_weak2) Hashtbl.t = <abstr>\n\n# Hashtbl.add my_htable \"A\" \"John\";\n  Hashtbl.add my_htable \"A\" \"Jane\";\n  Hashtbl.add my_htable \"B\" \"Max\";;\n```\n\n#### Find Data\n\n```ml\n# Hashtbl.find my_htable \"A\";;\n- : string = \"Jane\"\n\n(* find all *)\n# Hashtbl.find_all my_htable \"A\";;\n- : string list = [\"Jane\"; \"John\"]\n```\n\n### Maps\n\nMaps are immutable key-value association tables.\n\n#### Initialization & Add Data\n\n```ml\n(* the Map.Make functor creates the custom map module *)\n# module StringMap = Map.Make(String);;\n\nlet books =\n  StringMap.empty\n  |> StringMap.add \"Dune\" (\"Herbet\", 1965)\n  |> StringMap.add \"Neuromancer\" (\"Gibson\", 1984)\n```\n\n#### Finding Entries\n\n```ml\n(* find_opt returns assoc val wrapped in an option else None *)\n# StringMap.find_opt \"Dune\" books;;\n- : (string * int) option = Some (\"Herbet\", 1965)\n\n(* find returns the association else Not_Found *)\n# StringMap.find \"Dune\" books;;\n- : string * int = (\"Herbet\", 1965)\n```\n\n#### Adding & Removing Entries\n\nCreates a new map since maps are immutable\n\n```ml\nlet more_books = books\n  |> StringMap.add \"Foundation\" (\"Isaac Asimov\", 1951)\n\nlet less_books =\n  |> StringMap.remove \"Dune\"\n```\n\nFiltering\n\n```ml\nlet eighties_books =\n    StringMap.filter\n      (fun _ (_, year) -> year > 1980 & number < 1990) books\n```\n\n#### Printing Data\n\n```ml\nlet print_books map =\n  StringMap.iter (fun title (author, year) ->\n    Printf.printf \"Title: %s, Author: %s, Year: %d\\n\" title author year\n  ) map\n\n# let () = print_books eighties_books;;\nTitle: Neuromancer, Author: Gibson, Year: 1984\n```\n"
}