{
  "id": "ruby",
  "title": "Ruby",
  "intro": "|\nThe [Ruby](https://www.ruby-lang.org/) cheat sheet is a one-page reference sheet for the Ruby programming language.",
  "tags": [
    "script",
    "interpret"
  ],
  "categories": [
    "Programming"
  ],
  "background": "bg-red-500",
  "content": "## Getting Started\n\n### Install\n\n```bash\n# Debian, Ubuntu\n$ sudo apt-get install ruby-full\n# Windows\n$ winget install RubyInstallerTeam.Ruby\n$ brew install ruby # macOS\n$ docker run -it --rm ruby:latest # Docker\n```\n\n### What is Gemfile and Gemfile.lock {.row-span-2}\n\n- [Gemfile](https://bundler.io/v2.3/man/gemfile.5.html) Is the Bundler (also gem) configuration file that contains the\n  project's gem list (dependencies)\n\n```ruby\n# Specify gem in the Gemfile in the project root directory\nruby '3.1.2'\n\nsource 'https://rubygems.org'\ngem 'nokogiri'\ngem 'rack', '~>3.0.10'\ngem 'rspec', :require => 'spec'\n```\n\nInstall all gems in Gemfile\n\n```bash\n$ bundle install\n```\n\nSolve the problem of Gemfile.lock inconsistency between mac for development and linux for production\n\n```bash\nbundle lock --add-platform x86_64-linux\n```\n\n### Install a specific version of a specific ruby gem\n\n```bash\n$ gem install bundler -v 2.4.20\n$ gem install minitest -v 5.22.3\n```\n\n### Update gems using Bundler\n\n```bash\n# Updating a single gem using Bundler\n$ bundle update nokogiri\n# Use Bundler to update each gem in the Gemfile\n$ bundle update\n```\n\n### Comment {.row-span-1}\n\n```ruby\n# This is a single line comments.\n=begin\nMulti-line\nComment\n=end\nputs \"Hello world!\"  # Inline comments for code\n```\n\n### reserved words {.col-span-1}\n\n| Reserved words | Description                                                                                                |\n| :------------- | :--------------------------------------------------------------------------------------------------------- |\n| `__ENCODING__` | The script encoding of the current file                                                                    |\n| `__LINE__`     | The line number of this keyword in the current file                                                        |\n| `__FILE__`     | The path of the current file                                                                               |\n| `BEGIN`        | Code enclosed in { } is run before the program is run                                                      |\n| `END`          | Code enclosed in { } is run at the end of the program                                                      |\n| `alias`        | Create an alias for an existing method, operator, or global variable                                       |\n| `and`          | Logical AND operator                                                                                       |\n| `begin`        | Begin a block of code                                                                                      |\n| `break`        | Terminate a loop                                                                                           |\n| `case`         | Compare an expression with matching `when` clauses, terminated with <br/> `end`                            |\n| `class`        | Define a class                                                                                             |\n| `def`          | define a function/method                                                                                   |\n| `defined?`     | Check if a variable or function exist                                                                      |\n| `do`           | Start a block of code, terminated with the <br/> `end` keyword                                             |\n| `else`         | Execute the following code if previous conditions are not met                                              |\n| `elsif`        | Alternative condition for if expressions                                                                   |\n| `end`          | End blocks of code starting with keywords like `begin`, `class`,`def`,`do`,`if`, etc.                      |\n| `ensure`       | Always execute at the end of a block                                                                       |\n| `false`        | Logical boolean value false                                                                                |\n| `for`          | Start a `for` loop                                                                                         |\n| `if`           | Execute the code block `if` the condition is `true`                                                        |\n| `in`           | Used with `for` loop                                                                                       |\n| `module`       | Define a module                                                                                            |\n| `next`         | jump to the point before the evaluation of the loop condition                                              |\n| `nil`          | Stand for null, invalid, or always false                                                                   |\n| `not`          | Logical NOT operator                                                                                       |\n| `or`           | Logical OR operator                                                                                        |\n| `redo`         | Jump back to the loop condition evaluation                                                                 |\n| `rescue`       | Evaluate expressions after an exception is raised                                                          |\n| `retry`        | Repeat method calls when called outside `rescue`, jump to the top of the block when called inside `rescue` |\n| `return`       | Return a value from a method or block                                                                      |\n| `self`         | Refer to the current object                                                                                |\n| `super`        | Call the same-named method in the superclass                                                               |\n| `then`         | Used as a separator with`if`,`unless`,`when`,`case`,`rescue`                                               |\n| `true`         | Logical boolean value true                                                                                 |\n| `undef`        | Undefine methods/functions within the current class                                                        |\n| `until`        | Execute the code block until the condition is false                                                        |\n| `when`         | Begin a clause under a `case` statement                                                                    |\n| `while`        | Execute the code block while the condition is true                                                         |\n| `yield`        | Execute the code block passed to a method                                                                  |\n\n### Operator {.row-span-7}\n\n#### Logical Operators\n\n- `and`\n- `or`\n- `not`\n- `&&`\n- `||`\n- `!`\n\n#### Bit operators\n\n- `&`\n- `|`\n- `^`\n- `~`\n- `<<`\n- `>>`\n\n#### Arithmetic operators\n\n- `+`\n- `-`\n- `*`\n- `/`\n- `%`\n- `**`\n\n#### Comparison operator\n\n- `==`\n- `!=`\n- `>`\n- `<`\n- `>=`\n- `<=`\n- `<=>`\n- `===`\n- `eql?`\n- `equal?`\n\n#### Operator examples\n\n```bash\n# Addition\n1 + 1   #=> 2\n# Subtraction\n2 - 1   #=> 1\n# Multiplication\n2 * 2   #=> 4\n# Division\n10 / 5  #=> 2\n17 / 5    #=> 3, not 3.4\n17 / 5.0  #=> 3.4\n# Exponentiation\n2 ** 2  #=> 4\n3 ** 4  #=> 81\n# Modulus (remainder of division)\n8 % 2   #=> 0  (8 / 2 = 4; no remainder)\n10 % 4  #=> 2  (10 / 4 = 2 remainder 2)\na = 10\nb = 20\na == b #=> false\na != b #=> true\na > b #=> false\na < b #=> true\na >= b #=> false\na <= b #=> true\n\n# Comparison operators\na <=> b #=> -1\nc = 20\nc <=> b #=> 0\nc <=> a  #=> 1\n# Equality used in when clauses for case statements\n(1...10) === 5 #=> true\n# True if the receiver and the argument have the same type and equal values\n1.eql?(1.0) #=> false\nc = a + b  #=> 30\nc += a #=> 40\nc -= a #=> 30\nc *= a #=> 300\nc /= a #=> 30\nc %= a #=> 3\nc **= a #=> 59049\n\n# Ruby parallel assignment\na = 10\nb = 20\nc = 30\na, b, c = 10, 20, 30\n# Ruby bitwise operators\na = 60\nb = 13\n# & Binary AND operator copies a bit to the result if it exists in both operands.\na & b #=> 12\n# | Binary OR operator copies a bit if it exists in either operand.\na | b #=> 61\n# ^ Binary XOR operator copies a bit if it is set in one operand but not both.\na ^ b #=> 49\n# ~ Binary Ones Complement is unary and has the effect of 'flipping' bits.\n~a\n# << Binary Left Shift Operator. The left operand's value is moved\n# left by the number of bits specified by the right operand.\na << 2\n# >> Binary Right Shift Operator. The left operand's value is moved\n# right by the number of bits specified by the right operand.\na >> 2\n\n# Ruby logical operators\na and b #=> true.\na or b #=> true.\na && b #=> true.\n(a || b) #=> true.\n!(a && b) #=> false.\nnot(a && b) #=> false.\n# Ruby ternary operator\n# ? :\n# If condition is true ? Then value X : Otherwise value Y\na == 10 ? puts 'Right' : puts 'Wrong'\n# Ruby range operators\n# .. Creates a range from the start point to the end point (inclusive)\n1..10 #=> Creates a range from 1 to 10 (inclusive of 1 and 10)\n# ... Creates an exclusive range from the start point to the end point\n1...10 #=> Creates an exclusive range from 1 to 10\n```\n\n### Operator precedence table\n\nFrom highest to lowest, this is the precedence table for ruby. High precedence operations happen before low precedence\noperations.\n\n- !, ~, unary +\n- \\*\\*\n- unary -\n- \\*, /, %\n- +, -\n- <<, >>\n- &\n- |, ^\n- > , >=, <, <=\n- <=>, ==, ===, !=, =~, !~\n- &&\n- ||\n- .., ...\n- ?, :\n- modifier-rescue\n- =, +=, -=, etc.\n- defined?\n- not\n- or, and\n- modifier-if, modifier-unless, modifier-while, modifier-until\n- { } blocks\n\n### Variables and scope {.col-span-2}\n\n| -              | -                 | -                             | -                                                                                                |\n| -------------- | ----------------- | ----------------------------- | :----------------------------------------------------------------------------------------------- |\n| Name           | Scope             | Example                       | Explanation                                                                                      |\n| `[a-z]` or `_` | Local             | `count = 10` or `_count = 10` | Local variables must be initialized                                                              |\n| `@`            | Instance variable | `@id = []`                    | Instance variables have a \"nil\" value before initialization                                      |\n| `@@`           | Class variable    | `@@name = []`                 | Class variables must be initialized                                                              |\n| `$`            | Global variable   | `$version = \"0.8.9\"`          | Global variables have a \"nil\" value before initialization                                        |\n| `[A-Z]`        | Constant          | `PI = 3.14`                   | Constant variables must be initialized, you can change constants, but you will receive a warning |\n\nThere are five different types of variables. The first character determines the range To read in deap about variables\ncheck [User Guide](https://ruby-doc.org/docs/ruby-doc-bundle/UsersGuide/rg/) cap 19,20,21,22,23\n[Pre-Defined Variables and Constants](https://ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/variable.html)\n\n### Check the scope of a variable\n\n```ruby\ndefined? count\n\"local-variable\"\ndefined? @id\n\"instance-variable\"\ndefined? @@name\n\"class variable\"\ndefined? $version\n\"global-variable\"\ndefined? PI\n\"constant\"\n```\n\n### Data Types {.col-span-2}\n\n| -         | -                            | -                                                  | -                                                                                                               |\n| :-------- | :--------------------------- | :------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------- |\n| Type      | Example                      | Class                                              | Documentation                                                                                                   |\n| `Integer` | a = 17                       | a.class > Integer <br>a.class.superclass > Numeric | [#](<(https://ruby-doc.org/3.3.1/Integer.html)>)                                                                |\n| `Float`   | a = 87.23                    | a.class > Float <br>a.class.superclass > Numeric   | [#](https://ruby-doc.org/3.3.1/Float.html)                                                                      |\n| `String`  | a = \"Hello universe\"         | a.class > String                                   | [#](https://ruby-doc.org/3.3.1/String.html)                                                                     |\n| `Array`   | a = [12, 34]                 | a.class > Array                                    | [#](https://ruby-doc.org/3.3.1/Array.html)                                                                      |\n| `Hash`    | a = {type: \"tea\", count: 10} | a.class > Hash                                     | [#](https://ruby-doc.org/3.3.1/Hash.html)                                                                       |\n| `Boolean` | a = false<br>a = true        | a.class > FalseClass <br>a.class > TrueClass       | [TrueClass](https://ruby-doc.org/3.3.1/TrueClass.html) [FalseClass](https://ruby-doc.org/3.3.1/FalseClass.html) |\n| `Symbol`  | a = :status                  | a.class > Symbol                                   | [#](https://ruby-doc.org/3.3.1/Symbol.html)                                                                     |\n| `Range`   | a = 1..3                     | a.class > Range                                    | [#](https://ruby-doc.org/3.3.1/Range.html)                                                                      |\n| `Nil`     | a = nil                      | a.class > NilClass                                 | [#](https://ruby-doc.org/3.3.1/NilClass.html)                                                                   |\n\n[further reading](https://www.digitalocean.com/community/tutorials/understanding-data-types-in-ruby)\n\n### Check data type\n\n```ruby\n# Both are synonyms\na = 37\na.kind_of? Integer\n# true\na.is_a? Integer\n# true\n```\n\n### Symbol\n\n```ruby\nweek_days = {sunday: 11, monday: 222}\n```\n\n### Integer useful methods\n\n```ruby\n2.even?\n# true\n3.even?\n# false\n```\n\n### Range\n\n`..` Used to create inclusive ranges\n\n```ruby\nrange = 1..10\nrange.to_a\n# output => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n`...` Used to create exclusive ranges\n\n```ruby\nrange = 1...10\nrange.to_a\n# output => [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\nsome useful methods\n\n| Method name | Output                                |\n| :---------- | :------------------------------------ |\n| `cover?`    | `(1..5).cover?(5)` => `true`          |\n| `end`       | `('a'..'z').end` => `\"z\"`             |\n| `first`     | `(1..5).first` => `1`                 |\n| `first(3)`  | `('A'..'Z').first(2)` => `[\"A\", \"B\"]` |\n| `eql?`      | `((0..2).eql?(0..5)` => `false`       |\n\n### Using `step` in Range\n\n```ruby\n(1..20).step(2) { |number| puts \"#{number}\"}\n# output\n# 1\n# 3\n# 5\n# 7\n# 9\n# 11\n# 13\n# 15\n# 17\n# 19\n```\n\n## Ruby Flow control\n\n### if\n\n```ruby\nnum = 2\nputs 'two' if num == 2\n```\n\nIf the condition is true, execute the code\n\n### if elsif else\n\n```ruby\ntemp = 19\nif temp >= 25\n  puts \"hot\"\nelsif temp < 25 && temp >= 18\n  puts \"normal\"\nelse\n  puts \"cold\"\nend\n# output => normal\n```\n\n### unless\n\n```ruby\n# Unless contrary to if , evaluates when the statement is false\nname = \"rob\"\n# if name != \"bob\"\nunless name == \"bob\"\n  puts \"hello stranger\"\nelse\n  puts \"hello bob\"\nend\n# output => hello stranger\nnum = 6\nputs 'not two' unless num == 2\n# output => not two\n```\n\n### case {.row-span-2}\n\n```ruby\n# case returns the value of the last expression executed\ncase input\n# Check for an integer, 19\nwhen 19\n  puts \"It's 19\"\n  # Check for an exact string，“Zaman”\nwhen \"Zaman\"\n  puts \"Hi Zaman\"\nwhen 7..11\n  puts \"It's between 7 and 11\"\n  # Check multiple values, \"coffee\"\nwhen \"tea\", \"coffee\"\n  puts \"Happy days\"\nend\n```\n\n### case( short syntax )\n\n```ruby\ncase input\n  when 19 then puts \"It's 19\"\nend\n```\n\n### case( Optional failure )\n\n```ruby\ncase input\n  when 19 then puts \"It's 19\"\nelse\n  puts \"It's not 19\"\nend\n```\n\n### case( Get return value )\n\n```ruby\nmarks = 86\nresult = case marks\n        when 0..49 then \"Fail\"\n        when 50..64 then \"Pass\"\n        when 65..74 then \"Credit\"\n        when 75..84 then \"Distinction\"\n        when 85..100 then \"High Distinction\"\n        else \"Invalid marks\"\n        end\n\nputs result\n# High Distinction\n```\n\n## String\n\n### String interpolation\n\n```ruby\nname = \"World\"\nputs \"Hello #{name}\"\nputs \"The total is #{1+1}\"\n# \"the total is 2\"\n```\n\nString interpolation allows you to combine strings together\n\n### Extract substring\n\n```ruby\nstring = \"abc123\"\nstring[0,3]\n# \"abc\"\nstring[3,3]\n# \"123\"\nstring[0..-2]\n# \"abc12\"\n#remove or replace the substring\nstring[0..2] = \"\"\nputs string\n# \"123\"\n```\n\nA substring is a small part of a string, which is useful if you only want that specific part, like the beginning,\nmiddle, or end\n\n### Convert a string to lowercase or uppercase\n\n```ruby\n\"HELLO World\".downcase  # \"hello world\"\n\"hello worlD\".upcase    # \"HELLO WORLD\"\n\"hEllo wOrlD\".capitalize # \"Hello world\"\n\"hEllo WOrlD\".swapcase  # \"HeLLO woRLd\"\n```\n\n### useful methods {.col-span-3}\n\n| Function Name                  | Output                                                                                                | Note                                                                                                                                                                                |\n| :----------------------------- | :---------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| length or size                 | `\"HELLO World\".length` => `11` <br> `\"HELLO World\".size` => `11`                                      | Returns the length of the string                                                                                                                                                    |\n| reverse                        | `\"hello worlD\".reverse` => `\"Dlrow olleh\"`                                                            | Returns the reversed string                                                                                                                                                         |\n| include? other_str             | `\"hEllo wOrlD\".include? \"w\"` => `true`                                                                | Returns true if the string or character exists, otherwise returns false                                                                                                             |\n| gsub(pattern, replacement)     | `\"hEllo wOrlD\".gsub(\" \", \"_\")` => `\"hEllo_wOrlD\"`                                                     | gsub or global substitute replaces one or more strings with the provided string                                                                                                     |\n| gsub(pattern, hash)            | `\"organization\".gsub(\"z\", 'z' => 's')` => `\"organisation\"`                                            | gsub or global substitute replaces one or more strings with the provided hash                                                                                                       |\n| gsub(pattern) {\\|match\\|block} | `\"Price of the phone is 1000 AUD\".gsub(/\\d+/) {\\| s\\| '$'+s }`<br>`\"Price of the phone is $1000 AUD\"` | gsub or global substitute replaces one or more strings with the provided block                                                                                                      |\n| strip                          | `\" hEllo WOrlD \".strip` <br> `\"hEllo WOrlD\"`                                                          | It will remove (trim) any leading and trailing characters: null (“\\x00”), horizontal tab (“\\t”), newline (\\n), vertical tab (“\\v”), form feed (f), carriage return(\\r), space (\" \") |\n| prepend                        | `a = \"world\" <br> a.prepend(\"hello \")` <br> `\"hello world\"`                                           | Adds the string before another string                                                                                                                                               |\n| insert                         | `a = \"hello\" <br> a.insert(a.length, \" world\")` <br> `\"hello world\"`                                  | Inserts the string at a specific position                                                                                                                                           |\n| start_with?                    | `string = \"ruby programming\"` <br> `string.start_with? \"ruby\"` <br> `true`                            | Checks if the string starts with a specific prefix                                                                                                                                  |\n| end_with?                      | `string = \"ruby programming\"` <br> `string.end_with? \"ruby\"` <br> `false`                             | Checks if the string ends with a specific prefix                                                                                                                                    |\n| delete_suffix                  | `string = \"sausage is expensive\"` <br> `string.delete_suffix(\" is expensive\")` <br> `\"sausage\"`       | Deletes the suffix from the string                                                                                                                                                  |\n| delete_prefix                  | `string = \"sausage is expensive\"` <br> `string.delete_prefix(\"sausage\")` <br> `\" is expensive\"`       | Deletes the prefix from the string                                                                                                                                                  |\n| split                          | `string = \"a b c d\" <br> string.split` <br> `[\"a\", \"b\", \"c\", \"d\"]`                                    | Converts the string into an array of characters                                                                                                                                     |\n| join                           | `arr = ['a', 'b', 'c'] <br> arr.join` => `\"abc\"`                                                      | Converts an array into a string                                                                                                                                                     |\n| to_i                           | `a = \"49\" <br> a.to_i` => `49`                                                                        | Converts the string into an integer                                                                                                                                                 |\n| chop                           | `\"abcd?\".chop(\"?\")` => `\"abcd\"`                                                                       | Deletes the last character from the string                                                                                                                                          |\n| count                          | `str = \"aaab\" <br> str.count(\"a\")` <br> `3`                                                           | Counts the characters in the string                                                                                                                                                 |\n| to_f                           | `a = \"49\"` <br> `a.to_f` <br> `49.0`                                                                  | Converts the string into a floating point number                                                                                                                                    |\n| to_sym                         | `a = \"key\"` <br> `a.to_sym` <br> `:key`                                                               | Converts the string into a symbol                                                                                                                                                   |\n| match                          | `\"abcd?\".match(/ab/)` => `#<MatchData \"ab\">`                                                          | Converts the pattern into a regular expression and calls its match method on the string                                                                                             |\n| empty?                         | `\"hello\".empty?` => `false`                                                                           | Returns true if the length of the string is zero                                                                                                                                    |\n| squeeze                        | `\"Booook\".squeeze` => `\"Bok\"`                                                                         | Returns a copy of the string where runs of the same character are replaced by a single character                                                                                    |\n| \\*                             | `puts \"Ruby \" * 4` => `Ruby Ruby Ruby Ruby`                                                           | Returns the concatenation of multiple copies of self                                                                                                                                |\n| +                              | `\"sammy \" + \"shark\"` => `\"sammyshark\"`                                                                | Returns the concatenation of self and the given other string                                                                                                                        |\n| eql?                           | `s = 'foo'` => `true` <br> `s.eql?('foo')` => `true`                                                  | Returns true if the objects have the same length and content; false otherwise                                                                                                       |\n\n## Methods\n\n### Declare a method {.row-span-3}\n\n```ruby\ndef method_name(parameter1, parameter2)\n    puts \"#{parameter1} #{parameter2}\"\n    parameter1 + parameter2\nend\n```\n\n---\n\n```ruby\nres = method_name(20, 10)\n# output => 30\ndef method_name(parameter1, parameter2)\n    puts \"#{parameter1} #{parameter2}\"\n    return parameter1 + parameter2\nend\n# output => 30\n```\n\n### Call method\n\n```ruby\nres = method_name(parameter1, parameter2)\n# Methods can be called without parentheses\nres = method_name parameter1, parameter2\n```\n\n### Class method {.row-span-4}\n\nClass methods are class-level methods. There are multiple ways to define class methods\n\n```ruby\nclass Mobile\n    def self.ring\n        \"ring ring ring...\"\n    end\nend\n\nMobile.ring\n```\n\n---\n\n```ruby\nclass Mobile\n    def Mobile.ring\n        \"ring ring ring...\"\n    end\nend\nMobile.ring\n```\n\n---\n\n```ruby\nclass Mobile\n    class << self\n    def ring\n        \"ring ring ring...\"\n       end\n    end\nend\nMobile.ring\n```\n\nClass methods are instance methods of class objects. When a new class is created, an object of type \"Class\" is\ninitialized and assigned to a global constant (in this case Mobile)\n\n```ruby\nMobile = Class.new do\n    def self.ring\n        \"ring ring ring...\"\n    end\nend\nMobile.ring\n```\n\n```ruby\nMobile = Class.new\nclass << Mobile\n    def ring\n        \"ring ring ring...\"\n    end\nend\nMobile.ring\n```\n\n### Use another parameter as default value\n\n```ruby\ndef method_name(num1, num2 = num1)\n    return num1 + num2\nend\nres = method_name(10)\n# output => 20\n```\n\n### Define default values for method parameters\n\n```ruby\ndef method_name(parameter1, parameter2, type = \"ADD\")\n    puts \"#{parameter1} #{parameter2}\"\n    return parameter1 + parameter2 if type == \"ADD\"\n    return parameter1 - parameter2 if type == \"SUB\"\nend\nres = method_name(20, 10)\n# output => 30\n```\n\n### Pass variable length arguments to method parameters\n\n```ruby\ndef method_name(type, *values)\n    return values.reduce(:+) if type == \"ADD\"\n    return values.reduce(:-) if type == \"SUB\"\nend\nnumbers = [2, 2, 2, 3, 3, 3]\nres = method_name(\"ADD\", *numbers)\n# output => 15\nres = method_name(\"SUB\", *numbers)\n# output => -11\n# Or you can provide a value like this\nres = method_name(\"ADD\", 2, 2, 2, 3, 3, 3)\n# output => 15\n```\n\n### Modify object\n\n```ruby\na = [\"Drama\", \"Mystery\", \"Crime\",\n\"Sci-fi\", \"Disaster\", \"Thriller\"]\na.sort\nputs a\n# We did not modify the object\n# Drama\n# Mystery\n# Crime\n# Sci-fi\n# Disaster\n# Thriller\na.sort!\nputs a\n# Modify object\n# Crime\n# Disaster\n# Drama\n# Mystery\n# Sci-fi\n# Thriller\n```\n\nWhen you want to modify the object, use `!` after the method\n\n### Boolean method\n\nIn ruby, methods ending with a question mark (?) are called boolean methods, which return `true` or `false`\n\n```ruby\n\"some text\".nil?\n# false\nnil.nil?\n# true\n```\n\nYou can have your own boolean method\n\n```ruby\ndef is_vowel?(char)\n    ['a','e','i','o','u'].include? char\nend\nis_vowel? 'a'\n# true\nis_vowel? 'b'\n# false\n```\n\n## Blocks\n\n### Block example\n\n```ruby\n# return value\ndef give_me_data\n    data = yield\n    puts \"data = #{data}\"\nend\ngive_me_data { \"Big data\" }\n# output => data = Big data\n```\n\nThe code between `do` and `end` (for multiple lines) or curly braces `{` and `}` (for a single line) is called a block,\nand they can define multiple parameters between two pipes `( |arg1, arg2|)`\n\n### Single line block\n\n```ruby\nsalary = [399, 234, 566, 533, 233]\nsalary.each { |s| puts s }\n# puts s = block body\n# |s| = block arguments\n```\n\n### Multi-line block\n\n```ruby\nsalary.each do |s|\n    a = 10\n    res = a * s\n    puts res\nend\n# Block\n# a = 10\n# res = a * s\n# puts res\n# block parameters\n# |s|\n```\n\nBlocks can be passed as method parameters or associated with method calls. block returns the last evaluated statement\n\n### Implicitly passing a block\n\n```ruby\ndef give_me_data\n    puts \"I am inside give_me_data method\"\n    yield\n    puts \"I am back in give_me_data method\"\nend\n\ngive_me_data { puts \"Big data\" }\n\n# output\n# I am inside give_me_data method\n# Big data\n# I am back in give_me_data method\n```\n\n### Called multiple times\n\n```ruby\ndef give_me_data\n    yield\n    yield\n    yield\nend\n\ngive_me_data { puts \"Big data\" }\n\n# output\n# Big data\n# Big data\n# Big data\n```\n\n### Called with block parameters\n\n```ruby\ndef give_me_data\n    yield 10\n    yield 100\n    yield 30\nend\n\ngive_me_data { |data| puts \"Big data #{data} TB\" }\n\n# output\n# Big data 10 TB\n# Big data 100 TB\n# Big data 30 TB\n```\n\n### Called with multiple block parameters\n\n```ruby\ndef give_me_data\n    yield \"Big data\", 10, \"TB\"\n    yield \"Big data\", 100, \"GB\"\n    yield \"Big data\", 30, \"MB\"\nend\n\ngive_me_data { |text, data, unit| puts \"#{text} #{data} #{unit}\" }\n\n# output\n# Big data 10 TB\n# Big data 100 GB\n# Big data 30 MB\n```\n\n### Block will attempt to return from the current context\n\n```ruby\ngive_me_data\n    puts \"I'm inside the give_me_data method\"\nend\n\ndef test\n  puts \"I'm inside the test method\"\n  give_me_data { return 10 } # Code returns from here\n  puts \"I am back in test method\"\nend\n\nreturn_value = test\n\n# output\n# I'm inside the test method\n# I'm inside the give_me_data method\n# 10\n```\n\n### Pass the block explicitly by using the & parameter\n\n```ruby\ndef give_me_data(&block)\n    block.call\n    block.call\nend\n\ngive_me_data { puts \"Big data\" }\n\n# output\n# Big data\n# Big data\n```\n\n### Check if block is given\n\n```ruby\ndef give_me_data\n    yield\nend\n\ngive_me_data\n\n# output\n# LocalJumpError: no block given (yield)\n```\n\n### Ways to handle exceptions and make blocks optional\n\n```ruby\ndef give_me_data\n    return \"no block\" unless block_given?\n    yield\nend\n\ngive_me_data { puts \"Big data\" }\ngive_me_data\n\n# output\n# Big data\n```\n\n## Procs\n\n### Procs\n\n```ruby\np = Proc.new { puts \"Hello World\" }\n\ndef give_me_data(proc)\n    proc.call\nend\n\ngive_me_data p\n\n# output\n# Hello World\n```\n\nproc is like a block that can be stored in a variable\n\n### any parameter {.col-span-2}\n\n```ruby\np = Proc.new { |count| \"Hello World \" * count }\n\ndef give_me_data(proc)\n    proc.call 5, 2\nend\n\ngive_me_data p\n\n# output\n# \"Hello World Hello World Hello World Hello World Hello World \"\n```\n\n### proc will attempt to return from the current context\n\n```ruby\np = Proc.new { return 10 }\np.call\n# output\nLocalJumpError: unexpected return\n```\n\n### Cannot return from top-level context\n\n```ruby\ndef give_me_data\n    puts \"I'm inside the give_me_data method\"\n    p = Proc.new { return 10 }\n    p.call # Code returns from here\n    puts \"I am back in give_me_data method\"\nend\n\nreturn_value = give_me_data\nputs return_value\n\n# output\n# I'm inside the give_me_data method\n# 10\n```\n\n## Lambdas\n\n### Declare a lambda{.row-span-2}\n\n```ruby\nl = lambda { puts \"Hello World\" }\n# shorthand\nl = -> { puts \"Hello World\" }\n# transfer lambda\nl.call\n# output => Hello World\n```\n\nThere are multiple ways to call a lambda\n\n```ruby\nl.()\nl[]\n```\n\n### strict arguments\n\n```ruby\nl = -> (count) { \"Hello World \" * count }\nl.call 5\n# output\n# \"Hello World Hello World Hello World Hello World Hello World \"\nl.call 5, 2\n# output\nwrong number of arguments (given 2, expected 1)\n```\n\n### declare a lambda in block {.row-span-2}\n\n```ruby\ndef give_me_data\n    puts \"I am inside give_me_data method\"\n    l = -> { return 10 }\n    l.call\n    puts \"I am back in give_me_data method\"\nend\n\nreturn_value = give_me_data\nputs return_value\n\n# output\n# I am inside give_me_data method\n# I am back in give_me_data method\n# nil # because puts return nil\n```\n\n### lambdas are returned from the lambda itself, just like regular methods\n\n```ruby\nl = -> { return 10 }\nl.call\n\n# output => 10\n```\n\n## Array\n\n### Initialize an empty array\n\n```ruby\narray = Array.new   #=> []\n# or\narray = []\n```\n\n### Array containing objects of different types\n\n```ruby\narray = [1, \"two\", 3.0]\n#=> [1, \"two\", 3.0]\n```\n\n### Fill array with initial size and default objects {.row-span-2}\n\n```ruby\nnumbers = Array.new(3)\n#=> [nil, nil, nil]\nnumbers = Array.new(3, 7)\n#=> [7, 7, 7]\nnumbers = Array.new(3, true)\n#=> [true, true, true]\nnumbers = []\nnumbers.fill(7, 0..2)   #=> [7, 7, 7]\n```\n\n### array of different hashes {.col-span-2}\n\n```ruby\narray_with_hashes = Array.new(2) { {} } #=> [{}, {}]\narray_with_hashes[0][:name] = \"Bob\"\narray_with_hashes[0][:id] = 10          #=> [{:name=>\"Bob\", :id=>10}, {}]\n```\n\n### Two-dimensional array\n\n```ruby\ntemperature_data = [\n              [\"A908\", 38],\n              [\"A909\", 37],\n              [\"A910\", 38],\n          ]\ntemperature_data[0]    #=> [\"A908\", 38]\ntemperature_data[0][0] #=> \"A908\"\ntemperature_data[0][1] #=> 38\n```\n\n### array index\n\n```ruby\nstr_array = [\n  \"This\", \"is\", \"a\", \"small\", \"array\"\n]\nstr_array[0]            #=> \"This\"\nstr_array[1]            #=> \"is\"\nstr_array[4]            #=> \"array\"\n```\n\n### negative index\n\n```ruby\nstr_array = [\n  \"This\", \"is\", \"a\", \"small\", \"array\"\n]\n# Index -1 represents the last element\nstr_array[-1]        #=> \"array\"\n# Index -2 represents the second to last element\nstr_array[-2]        #=> \"small\"\nstr_array[-6]        #=> nil\n```\n\n### array method at\n\n```ruby\nstr_array = [\n  \"This\", \"is\", \"a\", \"small\", \"array\"\n]\n\nputs str_array.at(0)      #=> \"This\"\n```\n\n### Range acquisition\n\n```ruby\narr = [1, 2, 3, 4, 5, 6]\narr[100]                  #=> nil\narr[-3]                   #=> 4\narr[2, 3]                 #=> [3, 4, 5]\narr[1..4]                 #=> [2, 3, 4, 5]\narr[1..-3]                #=> [2, 3, 4]\n```\n\n### Array method fetch\n\n```ruby\narr = ['a', 'b', 'c', 'd', 'e', 'f']\narr.fetch(100)\n#=> IndexError: Index outside array bounds 100：-6...6\narr.fetch(100, \"oops\")    #=> \"oops\"\n```\n\nOut of bounds, give default value\n\n### Get array elements\n\n```ruby\narr = [1, 2, 3, 4, 5, 6]\n\narr.first     # first value => 1\narr.last      # last value => 6\n# take Returns the first n elements\narr.take(3)   #=> [1, 2, 3]\n# drop after n elements have been deleted\narr.drop(3)   #=> [4, 5, 6]\n```\n\n### Add value to end of array push\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.push(11)\n#=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nnumbers.push(12, 13, 14)\n#=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n```\n\n### Delete the value at the end of the array pop\n\n```ruby\nnum_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnum_array.pop             #=> 10\nnum_array\n#=> [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### Add value to beginning of array unshift\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.unshift(0)\n#=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.unshift(-3, -2, -1)\n#=> [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### Retrieve and simultaneously delete the first element shift\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.shift #=> 1\nnumbers\n#=> [2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### Remove element at specific index delete_at\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.delete_at(2) #=> 4\nnumbers\n#=> [2, 3, 5, 6, 7, 8, 9, 10]\n```\n\n### Remove a specific element anywhere in an array\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.delete(2) #=> 2\nnumbers           #=> [3, 5, 6, 7, 8, 9, 10]\n```\n\n### Insert value at given index insert {.row-span-2}\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.insert(0, 0)\n#=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.insert(0, -3, -2, -1)\n#=> [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nnumbers.insert(-1, 12, 13, 14)\n#=> [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14]\nnumbers.insert(-4, 11)\n#=> [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n```\n\n### A block to fill the array with values\n\n```ruby\nnumbers = Array.new(10) { |n| n = n * 2 }\n#=> [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n```\n\n### Filling arrays becomes easier\n\n```ruby\nnumbers = Array(100..110)\n#=> [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110]\n\n# Or we can convert the range to an array\n(100..110).to_a\n#=> [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110]\n```\n\n### Remove nil value from array\n\n```ruby\narr = ['foo', 0, nil, 'bar', 7, nil]\narr.compact  #=> ['foo', 0, 'bar', 7]\narr      #=> ['foo', 0, nil, 'bar', 7, nil]\narr.compact! #=> ['foo', 0, 'bar', 7]\narr      #=> ['foo', 0, 'bar', 7]\n```\n\n### Remove duplicates uniq\n\n```ruby\narr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]\narr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]\narr # => [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]\narr.uniq! #=> [2, 5, 6, 556, 8, 9, 0, 123]\narr #=> [2, 5, 6, 556, 8, 9, 0, 123]\n```\n\n### Check if a value exists in an array（`include？`）\n\n```ruby\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nplanets.include? \"Mars\"\n# output => true\nplanets.include? \"Pluto\"\n# output => false\n```\n\n### Get array size\n\n```ruby\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nplanets.size\n# output => 8\nplanets.length\n# output => 8\n```\n\nYou can use size or length, both are synonyms\n\n### clear array\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.clear\n# output => []\n```\n\n### Get the first element of the array\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers[0]\n# or\nnumbers.first\n# output => 1\n```\n\n### Get the last element of the array\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers[-1]\n# or\nnumbers.last\n# output => 10\n```\n\n### Merge two arrays\n\n```ruby\na = [\"tom\", \"mot\", \"otm\"]\nb = [2, 3, 5]\na.zip(b)\n# output\n# [[\"tom\", 2], [\"mot\", 3], [\"otm\", 5]]\n```\n\n### Sort array {.row-span-3}\n\n```ruby\nprimes = [7, 2, 3, 5]\nsorted_primes = primes.sort\nputs \"#{sorted_primes}\"\n# output => [2, 3, 5, 7]\n```\n\nor in-place sort\n\n```ruby\nprimes = [7, 2, 3, 5]\nprimes.sort!\nputs \"#{primes}\"\n# output => [2, 3, 5, 7]\n```\n\n```ruby\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nplanets.sort\n# output\n# [\"Earth\", \"Jupiter\", \"Mars\", \"Mercury\", \"Neptune\", \"Saturn\", \"Uranus\", \"Venus\"]\nplanets.sort_by { |p| p }\n# output\n# [\"Earth\", \"Jupiter\", \"Mars\", \"Mercury\", \"Neptune\", \"Saturn\", \"Uranus\", \"Venus\"]\nplanets.sort_by { |p| p.length }\n# output\n# [\"Mars\", \"Earth\", \"Venus\", \"Saturn\", \"Uranus\", \"Neptune\", \"Jupiter\", \"Mercury\"]\n```\n\n### Get maximum value from array\n\n```ruby\nprimes = [7, 2, 3, 5]\nprimes.max_by { |p| p }\n# output => 7\n```\n\n### Get array elements using range {.row-span-2}\n\n```ruby\n# numbers[start..end], both index are inclusive\nputs numbers[0..3]\n# 1\n# 2\n# 3\n# 4\n# numbers[start..end], end index is exclusive\nputs numbers[0...3]\n# 1\n# 2\n# 3\n# or numbers[start..length]\nputs numbers[0, 1]\n# 1\n```\n\n### Get the first n elements of the array\n\n```ruby\nprimes = [7, 2, 3, 5]\nprimes.take(3)\n# [7, 2, 3]\n```\n\n### access element\n\n```ruby\nprimes = [7, 2, 3, 5]\nprimes.fetch(3)\n# 5\n# Fetch will throw an error if the element does not exist\nprimes.fetch(10)\n# (index 10 outside of array bounds: -4...4)\n# or get an default value\nprimes.fetch(10, -1)\n# -1\n```\n\n### Delete first n elements\n\n```ruby\nprimes = [7, 2, 3, 5]\nprimes.drop(3)\n# [5]\n```\n\n### Delete the first element\n\n```ruby\nprimes = [7, 2, 3, 5]\nprimes.shift\n# [2, 3, 5]\n```\n\n### Remove last element\n\n```ruby\nprimes = [7, 2, 3, 5]\nprimes.pop\n# [7, 2, 3]\n```\n\n### Delete element with index\n\n```ruby\nprimes = [7, 2, 3, 5]\nprimes.delete_at(-1)\n# [7, 2, 3]\n```\n\n### Remove all occurrences of elements\n\n```ruby\nprimes = [7, 2, 3, 5, 5]\nprimes.delete(5)\n# [7, 2, 3]\n```\n\n### each {.row-span-3}\n\n```ruby\n# When you have single line blocks\nsalary = [399, 234, 566, 533, 233]\nsalary.each { |s| puts s }\n# output\n# 399\n# 234\n# 566\n# 533\n# 233\n```\n\nWhen you have a multi-line block, you can replace the curly braces `{}` with `do` and `end`\n\n```ruby\nsalary.each do |s|\n  a = 10\n  res = a * s\n  puts res\nend\n# output\n# 3990\n# 2340\n# 5660\n# 5330\n# 2330\n```\n\nOr you can do the same thing using braces {} and semicolon as separator instead of newline\n\n```ruby\nsalary.each { |s| a = 10 ; res = a * s ; puts res }\n```\n\n### each_with_index\n\n```ruby\nsalary = [399, 234, 566, 533, 233]\nsalary.each_with_index { |value, index| puts \"#{index} #{value}\" }\n# output\n# 0 399\n# 1 234\n# 2 566\n# 3 533\n# 4 233\n```\n\n### each_index\n\n```ruby\nsalary = [399, 234, 566, 533, 233]\nsalary.each_index { |i| puts i}\n# output\n# 0\n# 1\n# 2\n# 3\n# 4\n```\n\n### map\n\n```ruby\nsalary = [399, 234, 566, 533, 233]\nsalary.map { |s|  s * 10  }\n# return\n# [3990, 2340, 5660, 5330, 2330]\n# On the other hand, each returns the original value\nsalary = [399, 234, 566, 533, 233]\nsalary.each { |s|  s * 10  }\n# return\n# [399, 234, 566, 533, 233]\n```\n\n### collect\n\n```ruby\nsalary = [399, 234, 566, 533, 233]\nsalary.collect { |s| s > 400 }\n# output\n# [false, false, true, true, false]\n```\n\n### for\n\n```ruby\nfor value in [2, 3, 5, 7]\n    puts value\nend\n```\n\n### each_with_object {.col-span-2}\n\n```ruby\ncolors = [\n  {color: \"red\", count: 3}, {color: \"red\", count: 5}, {color: \"black\", count: 4}\n]\ncolors.each_with_object(Hash.new(0)) { |color, hash| hash[\"color_\"+color[:color]] = color[:color].upcase; hash[\"count_\"+color[:color]] += color[:count] }\n# output\n{\"color_red\"=>\"RED\", \"count_red\"=>8, \"color_black\"=>\"BLACK\", \"count_black\"=>4}\n\n[1, 2, 3].each_with_object(0) { |number, sum| sum += number}\n# output\n# 0\n# Because 0 is immutable, and since the initial object is 0, the method returns 0\n```\n\n### while\n\n```ruby\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nindex = 0\nwhile index < planets.size\n    puts \"#{planets[index]}\"\n    index += 1\nend\n```\n\n---\n\n```ruby\na = 1\nstar = '*'\nwhile a <= 10\n    puts star\n    star += '*'\n    a += 1\nend\n```\n\n### do while\n\n```ruby\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nindex = 0\nloop do\n    puts \"#{planets[index]}\"\n    index += 1\n    break if planets[index] == \"Mars\" or index > planets.size\nend\n```\n\n### until\n\n```ruby\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nindex = planets.size - 1\nuntil index < 0\n    puts \"#{planets[index]}\"\n    index -= 1\nend\n```\n\n```ruby\na = 1\nstar = '*'\nuntil star.length > 10\n    puts star\n    star += '*'\n    a += 1\nend\n```\n\n### times\n\n```ruby\n10.times { puts \"#{rand(1..100)}\"}\n# output\n# will print 10 random numbers\n```\n\nJust because you can doesn't mean you should iterate over an array like this\n\n```ruby\ndata_sample = [2, 3, 5, 7]\ndata_sample.size.times { |index| puts \"#{data_sample[index]}\" }\n# output\n# 2\n# 3\n# 5\n# 7\n```\n\n### upto\n\n```ruby\ndata_sample = [2, 3, 5, 7]\n0.upto((data_sample.size - 1) / 2) { |index| puts \"#{data_sample[index]}\" }\n# output\n# 2\n# 3\n```\n\n### downto\n\n```ruby\ndata_sample = [2, 3, 5, 7]\n(data_sample.size - 1).downto(data_sample.size / 2) { |index| puts \"#{data_sample[index]}\" }\n# output\n# 7\n# 5\n```\n\n### step {.row-span-2}\n\n```ruby\n1.step(20, 2) { |number| puts \"#{number}\"}\n# output\n# 1\n# 3\n# 5\n# 7\n# 9\n# 11\n# 13\n# 15\n# 17\n# 19\n```\n\n---\n\n```ruby\n19.step(1, -2) { |number| puts \"#{number}\"}\n# output\n# 19\n# 17\n# 15\n# 13\n# 11\n# 9\n# 7\n# 5\n# 3\n# 1\n```\n\n### inject {.row-span-2}\n\n```ruby\nnumbers = [2, 2, 2, 2, 2]\nnumbers.inject{ |res, n| res + n }\n# The output is the sum of all numbers\n# If no initial value is set for res, the first element of the array is used as the initial value of res.\n#10\n# Now set the value of res to 11\nnumbers = [2, 2, 2, 2, 2]\nnumbers.inject(11) { |res, n| res + n }\n# so 11 + 2, 13 + 2, 15 + 2, 17 + 2 and 19 + 2\n# 21\n# using symbol\nnumbers = [2, 2, 2, 2, 2]\nnumbers.inject(:+)\n# output\n# 10\n```\n\nUse initial values and symbols\n\n```ruby\nnumbers = [2, 2, 2, 2, 2]\nnumbers.inject(11, :+)\n# output\n# 21\n```\n\n### reduce\n\n```ruby\nnumbers = [2, 2, 2, 2, 2]\nnumbers.reduce(11, :+)\n# output\n# 21\n```\n\n### detect\n\n```ruby\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nplanets.detect { |name| name.start_with?(\"E\") and name.end_with?(\"h\") }\n# output\n# Earth\nsalary = [399, 234, 566, 533, 233]\nsalary.detect { |s| s > 1000 }\n# output\n# nil\n```\n\n### find\n\n```ruby\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nplanets.find { |name| name.start_with?(\"E\") and name.end_with?(\"h\") }\n# output\n# Earth\n```\n\n### select\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.select { |n| n % 2 == 0 }\n# Now you have an even array\n# [2, 4, 6, 8, 10]\n# If there are no values that satisfy your logic, return an empty array\n[1, 1, 1].select { |n| n % 2 == 0 }\n# no even numbers\n# []\n```\n\n### reject\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.reject { |n| n % 2 == 0 }\n# Reject if the number is even, so now we have an odd array\n# [1, 3, 5, 7, 9]\n```\n\n### keep_if\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.keep_if { |n| n % 2 == 0 }\n# numbers Array contains only even numbers\n# [2, 4, 6, 8, 10]\n```\n\n### delete_if\n\n```ruby\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.delete_if { |n| n % 2 == 0 }\n# numbers Array contains only odd numbers\n# [1, 3, 5, 7, 9]\n```\n\n### drop_while\n\n```ruby\nnumbers = [1, 2, 3, 1, 2, 3, 0]\nnumbers.drop_while { |n| n < 3 }\n# is 3 less than 3, returns false, so delete 1, 2\n# [3, 1, 2, 3, 0]\n```\n\n### reverse_each\n\n```ruby\nwords = %w[first second third fourth fifth sixth]\nstr = \"\"\nwords.reverse_each {|word| str += \"#{word} \"}\np str #=> \"sixth fifth fourth third second first \"\n```\n\n## boolean enumerable method\n\n### boolean enumerable method {.row-span-2}\n\n| Name       | When to use                                                              |\n| :--------- | :----------------------------------------------------------------------- |\n| `all?`     | When you want to check if all elements meet your condition               |\n| `any?`     | When you want to check if at least one item meets your condition         |\n| `one?`     | When you want to check if one element meets your requirement             |\n| `none?`    | When you want to check if no item meets your condition, the opposite of? |\n| `empty?`   | When you want to check if an object is empty                             |\n| `include?` | When you want to check if an element exists in the object                |\n\n### all?\n\n```ruby\n[2, 4, 6, 8, 10].all? { |num| num % 2 == 0 }\n# true\n[1, 4, 6, 8, 10].all? { |num| num % 2 == 0 }\n# false\n```\n\n### any?\n\n```ruby\n[1, 3, 5, 7, 10].any? { |num| num % 2 == 0 }\n# true\n[1, 3, 5, 7, 19].any? { |num| num % 2 == 0 }\n# false\n```\n\n### one?\n\n```ruby\n[1, 3, 2, 5, 7].one? { |num| num % 2 == 0 }\n# true\n[1, 3, 2, 5, 4].one? { |num| num % 2 == 0 }\n# false\n```\n\n### none?\n\n```ruby\n[1, 3, 5, 7, 9].none? { |num| num % 2 == 0 }\n# true\n[2, 3, 5, 7, 9].none? { |num| num % 2 == 0 }\n# false\n```\n\n### empty?\n\n```ruby\n[].empty?\n# true\n[1, 3, 5, 7, 9].empty?\n# false\n```\n\n## Combination method\n\n### Combination method {.row-span-2}\n\n- `&` Returns a new array containing each element found in array and array other_array; duplicates are omitted; use eql?\n  to compare items\n- `intersection` Returns a new array containing each element found in self and all given arrays other_arrays; duplicates\n  are omitted; use eql? to compare items\n- `+` Returns an array containing all elements of self followed by all elements of the given array\n- `-` Returns an array containing all elements of self not found in the given array\n- `union` Returns an array containing all elements of self and all elements of the given array, with duplicates removed\n- `difference` Returns an array containing all elements of self not found in any given array\n- `product` self Returns or produces all combinations of elements from self and the given array\n\n### &\n\n```ruby\n[0, 1, 2, 3] & [1, 2] # => [1, 2]\n[0, 1, 0, 1] & [0, 1] # => [0, 1]\n```\n\n### intersection\n\n```ruby\n[0, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3])\n# => [0, 1]\n[0, 0, 1, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3])\n# => [0, 1]\n```\n\n### +\n\n```ruby\na = [0, 1] + [2, 3]\na # => [0, 1, 2, 3]\n```\n\n### -\n\n```ruby\n[0, 1, 1, 2, 1, 1, 3, 1, 1] - [1]\n# => [0, 2, 3]\n[0, 1, 2, 3] - [3, 0]\n# => [1, 2]\n[0, 1, 2] - [4]\n# => [0, 1, 2]\n```\n\n### union\n\n```ruby\n[0, 1, 2, 3].union([4, 5], [6, 7])\n# => [0, 1, 2, 3, 4, 5, 6, 7]\n[0, 1, 1].union([2, 1], [3, 1])\n# => [0, 1, 2, 3]\n[0, 1, 2, 3].union([3, 2], [1, 0])\n# => [0, 1, 2, 3]\n```\n\n### difference\n\n```ruby\n[0, 1, 1, 2, 1, 1, 3, 1, 1].difference([1])\n# => [0, 2, 3]\n[0, 1, 2, 3].difference([3, 0], [1, 3])\n# => [2]\n[0, 1, 2].difference([4])\n# => [0, 1, 2]\n```\n\n### product\n\n```ruby\na = [0, 1, 2]\na1 = [3, 4]\np = a.product(a1)\np.size # => 6 # a.size * a1.size\np # => [[0, 3], [0, 4], [1, 3], [1, 4], [2, 3], [2, 4]]\n```\n\n## Loops\n\n### while loop\n\n```ruby\n# variable count\ncount = 4\n# using while loop\n# here conditional is count i.e. 4\nwhile count >= 1\n  # statements to be executed\n  puts \"Ruby Cheatsheet\"\n  count = count - 1\n  # while loop ends here\nend\n```\n\noutput\n\n```\nRuby Cheatsheet\nRuby Cheatsheet\nRuby Cheatsheet\nRuby Cheatsheet\n```\n\n### for loop\n\n```ruby\n# loop using range as expression\ntext = \"Ruby Cheatsheet\"\n# using for loop with the range\nfor count in 1..5 do\n  puts text\nend\n```\n\noutput\n\n```\nRuby Cheatsheet\nRuby Cheatsheet\nRuby Cheatsheet\nRuby Cheatsheet\nRuby Cheatsheet\n```\n\n### do..while loop\n\n```ruby\n# starting of do..while loop\nloop do\n  puts \"Ruby Cheatsheet\"\n  val = '7'\n  # using boolean expressions\n  if val == '7'\n    break\n  end\n  # ending of ruby do..while loop\nend\n```\n\noutput\n\n```\nRuby Cheatsheet\n```\n\n### until loop\n\n```ruby\nvar = 7\n# here do is optional\nuntil var == 11 do\n  # code to be executed\n  puts var * 10\n  var = var + 1\n  # here loop ends\nend\n```\n\noutput\n\n```\n70\n80\n90\n100\n```\n\n### Break out of loop\n\n```ruby\nsalary = [399, 234, 566, 533, 233]\nsalary.each do |s|\n  break if s == 566\n  puts s\nend\n# output\n# 399\n# 234\n```\n\nBy using the `break` keyword\n\n### skip within loop\n\n```ruby\nsalary = [399, 234, 566, 533, 233]\nsalary.each do |s|\n  next if s == 533\n  puts s\nend\n# output\n# 399\n# 234\n# 566\n# 233\n```\n\nBy using next keyword\n\n### Repeat current iteration\n\n```ruby\ndata = [456, 3000]\nretry_count = 0\nstatus = \"network failure\"\nsum = 0\ndata.each do |d|\n    if retry_count == 3\n        status = \"connection established\"\n        retry_count = 0\n        redo\n    elsif status == \"network failure\" and retry_count < 5\n        puts \"network failure #{retry_count}\"\n        retry_count += 1\n        redo\n    elsif status == \"connection established\"\n        puts d\n        sum += d\n    end\nend\n# output of sum\n# 3456\n```\n\n### Start the cycle again\n\n```ruby\nnumbers = [2, 2, 44, 44]\nsum = 0\nbegin\n    numbers.each do |s|\n        if rand(1..10) == 5\n            puts \"hi 5, let's do it again!\"\n            sum = 0\n            raise \"hi 5\"\n        end\n        puts s\n        sum += s\n    end\nrescue\n    retry\nend\n```\n\n## Classes\n\n### Classes Example {.row-span-2}\n\n```ruby\nclass Person\n    # when you create a new object, it looks for a method named initialize and executes it, like a constructor in java\n    # def initialize(name, number)\n    #    @name = name\n    #    @number = number\n    # end\n    # instance variable\n    # @name\n    # class variable\n    # @@count\n    # attr_accessor acts as a getter and setter for the following instance attributes\n    attr_accessor :name, :number\n    # class variable must be initialized\n    @@count = 0\n    def self.count\n        @@count\n    end\n    def self.count=(count)\n        @@count = count\n    end\n    def initialize\n        @@count += 1\n    end\nend\n# create an instance of the Person class\np1 = Person.new\n# set attributes of the Person class\np1.name = \"Yukihiro Matsumoto\"\np1.number = 9999999999\n# get attributes of the Person class\nputs \"#{p1.name}\"\nputs \"#{p1.number}\"\nputs \"#{Person.count}\"\n# Yukihiro Matsumoto\n# 9999999999\n# 1\np2 = Person.new\np2.name = \"Yukihiro Matsumoto\"\np2.number = 9999999999\n# get attributes of the Person class\nputs \"#{p2.name}\"\nputs \"#{p2.number}\"\nputs \"#{Person.count}\"\n# Yukihiro Matsumoto\n# 9999999999\n# 2\n# set class variable\nPerson.count = 3\nputs \"#{Person.count}\"\n# 3\n```\n\n### Inherit a class\n\n```ruby\nclass Person\n    attr_accessor :name, :number\nend\n# Inherit methods and properties from parent class using < symbol\nclass Student < Person\n    attr_accessor :id\nend\ns = Student.new\ns.name = \"James Bond\"\ns.number = 700\ns.id = 678\nputs \"#{p.name}\"\nJames Bond\nputs \"#{p.number}\"\n700\nputs \"#{p.id}\"\n678\n```\n\n### Check instance type\n\n```ruby\nclass Vehicle; end\nclass Car < Vehicle; end\nclass Audi < Car; end\ncar = Car.new\ncar.instance_of? Vehicle\nfalse\ncar.instance_of? Car\ntrue\ncar.instance_of? Audi\nfalse\na = 7\na.instance_of? Integer\ntrue\na.instance_of? Numeric\nfalse\n```\n\nReturns true if the object is an instance of the given class and not a subclass or superclass\n\n### Print all method names of a class\n\n```ruby\nputs (String.methods).sort\n# Exclude methods inherited from Object class\nputs (String.methods - Object.public_instance_methods).sort\n```\n\n### Check if a class has a specific method\n\n```ruby\nString.respond_to?(:prepend)\ntrue\nString.respond_to?(:append)\nfalse\n```\n\n## See Also\n\n- [Ruby](https://www.ruby-lang.org/en/) _(ruby-lang.org)_\n- [Ruby Cheatsheet](https://github.com/lifeparticle/Ruby-Cheatsheet) _(github.com)_\n"
}