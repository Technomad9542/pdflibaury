{
  "id": "react-test-library",
  "title": "React Testing Library Cheat Sheet",
  "intro": "|\nWhen it comes to testing React apps manually, we can either choose to render individual component trees in a simplified test environment or run the complete app in a realistic browser environment (end-to-end testing). But for automated tests, React Testing Library (RTL) is recommended for its user-centric approach and maintainability.",
  "tags": [
    "react",
    "testing",
    "javascript",
    "cheatsheet"
  ],
  "categories": [
    "Testing"
  ],
  "background": "bg-blue-500",
  "content": "## Introduction\n\nReact Testing Library is built on top of DOM Testing Library to test React components by querying and interacting with real DOM nodes, avoiding reliance on implementation details.\n\n## Basic level\n\n### 1. Purpose & Solution\n\nRTL addresses maintainability by focusing on user-visible behavior:\n\n- Tests run in actual DOM nodes.\n- Queries mirror user interactions.\n- `data-testid` as an escape hatch when needed.\n- Encourages accessibility.\n\n### 2. A basic component render test\n\n**Component (App.js):**\n\n```js\nconst title = 'Hello, World!';\n\nfunction App() {\n  return <div>{title}</div>;\n}\n\nexport default App;\n```\n\n**Test (App.test.js):**\n\n```js\nimport { render } from '@testing-library/react';\nimport App from './App';\n\ndescribe('App', () => {\n  test('renders App component', () => {\n    render(<App />);\n  });\n});\n```\n\nAdd debug to inspect output:\n\n```js\nimport { render, screen } from '@testing-library/react';\nimport App from './App';\n\ndescribe('App', () => {\n  test('renders App component', () => {\n    render(<App />);\n    screen.debug();\n  });\n});\n```\n\nOutput in console:\n\n```html\n<body>\n  <div>\n    <div>Hello, World!</div>\n  </div>\n</body>\n```\n\n### 3. Why use RTL vs Enzyme?\n\n1. Tests based on user interactions, not internal APIs.\n2. Improves maintainability after refactors.\n3. Intuitive syntax (`getByText`, `getByAltText`, etc.).\n\n### 4. Queries in RTL\n\n```js\nimport { render, screen } from '@testing-library/react';\n\ntest('should show login form', () => {\n  render(<Login />);\n  const input = screen.getByLabelText('Username');\n  // events & assertions\n});\n```\n\n**Single element queries:**\n\n- `getBy*`: throws if none found\n- `queryBy*`: returns null if none\n- `findBy*`: async Promise\n\n**Multiple elements queries:**\n\n- `getAllBy*`: throws if none\n- `queryAllBy*`: returns \\[] if none\n- `findAllBy*`: async Promise array\n\n### 5. Component tree testing level\n\n- Test at user interaction level, not per individual child component unless needed.\n\n## Intermediate level\n\n### 1. Jest vs RTL\n\n- **Jest**: Test runner & assertion library (`describe`, `test`, `expect`).\n- **RTL**: DOM utilities for React; works within Jest (or other runners).\n\n### 2. Mocking with MSW\n\n```js\n// fetch.test.jsx\nimport React from 'react';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { render, fireEvent, waitFor, screen } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport Fetch from '../fetch';\n\nconst server = setupServer(\n  rest.get('/greeting', (req, res, ctx) =>\n    res(ctx.json({ greeting: 'hello there' }))\n  )\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ntest('loads and displays greeting', async () => {\n  render(<Fetch url=\"/greeting\" />);\n  fireEvent.click(screen.getByText('Load Greeting'));\n  await waitFor(() => screen.getByRole('heading'));\n  expect(screen.getByRole('heading')).toHaveTextContent('hello there');\n  expect(screen.getByRole('button')).toBeDisabled();\n});\n\ntest('handles server error', async () => {\n  server.use(rest.get('/greeting', (req, res, ctx) => res(ctx.status(500))));\n  render(<Fetch url=\"/greeting\" />);\n  fireEvent.click(screen.getByText('Load Greeting'));\n  await waitFor(() => screen.getByRole('alert'));\n  expect(screen.getByRole('alert')).toHaveTextContent('Oops, failed to fetch!');\n  expect(screen.getByRole('button')).not.toBeDisabled();\n});\n```\n\n### 3. `render` options\n\n```js\nimport { render } from '@testing-library/react';\nimport '@testing-library/jest-dom';\n\ntest('renders a message', () => {\n  const table = document.createElement('table');\n  const { container } = render(<TableBody {...props} />, {\n    container: document.body.appendChild(table),\n    baseElement: document.body,\n    hydrate: true,\n    legacyRoot: true,\n    queries: {\n      /* custom queries */\n    }\n  });\n  expect(container).toBeInTheDocument();\n});\n```\n\n### 4. `renderHook` usage\n\n```js\nimport { renderHook } from '@testing-library/react';\n\ntest('returns logged in user', () => {\n  const { result, rerender } = renderHook(\n    ({ name } = {}) => useLoggedInUser(name),\n    { initialProps: { name: 'Alice' } }\n  );\n  expect(result.current).toEqual({ name: 'Alice' });\n  rerender({ name: 'Bob' });\n  expect(result.current).toEqual({ name: 'Bob' });\n});\n```\n\n## Advanced Level\n\n### 1. Adding custom queries\n\n```js\nconst dom = require('@testing-library/dom');\nconst { queryHelpers, buildQueries } = require('@testing-library/react');\n\n// Override testId attribute\nexport const queryByTestId = queryHelpers.queryByAttribute.bind(\n  null,\n  'data-test-id'\n);\nexport const queryAllByTestId = queryHelpers.queryAllByAttribute.bind(\n  null,\n  'data-test-id'\n);\nexport function getAllByTestId(container, id, ...rest) {\n  const els = queryAllByTestId(container, id, ...rest);\n  if (!els.length)\n    throw queryHelpers.getElementError(\n      `No element with [data-test-id=\"${id}\"]`,\n      container\n    );\n  return els;\n}\nexport function getByTestId(container, id, ...rest) {\n  const els = getAllByTestId(container, id, ...rest);\n  if (els.length > 1)\n    throw queryHelpers.getElementError(\n      `Multiple elements with [data-test-id=\"${id}\"]`,\n      container\n    );\n  return els[0];\n}\n```\n\nOr using `buildQueries`:\n\n```js\nconst queryAllByDataCy = (...args) =>\n  queryHelpers.queryAllByAttribute('data-cy', ...args);\nconst [\n  queryByDataCy,\n  getAllByDataCy,\n  getByDataCy,\n  findAllByDataCy,\n  findByDataCy\n] = buildQueries(\n  queryAllByDataCy,\n  (c, v) => `Found multiple elements with data-cy=\"${v}\"`,\n  (c, v) => `Unable to find element with data-cy=\"${v}\"`\n);\n```\n\n### 2. Skipping auto cleanup\n\n- Via CLI: `cross-env RTL_SKIP_AUTO_CLEANUP=true jest`\n- Or add to Jest `setupFiles`: `import '@testing-library/react/dont-cleanup-after-each';`\n\n### 3. Migrating from Enzyme\n\n1. Install RTL & jest-dom.\n2. Replace `shallow`/`mount` with `render` + `screen`.\n3. Migrate tests incrementally.\n\n### 4. Querying within elements\n\n```js\nimport { render, within } from '@testing-library/react';\n\nconst { getByText } = render(<MyComponent />);\nconst section = getByText('messages');\nconst hello = within(section).getByText('hello');\n```\n\n### 5. Integration testing\n\n```js\nimport { render, cleanup, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport nock from 'nock';\nimport App from '../App';\n\nconst REPOS = [{ name: 'repo1', description: '...' }];\n\nbeforeAll(() =>\n  nock('https://api.github.com')\n    .persist()\n    .get('/users/alice/repos')\n    .reply(200, REPOS)\n);\nafterEach(cleanup);\n\ntest('user sees public repos', async () => {\n  render(<App />);\n  userEvent.type(screen.getByPlaceholderText('Enter username'), 'alice');\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n  await waitFor(() =>\n    REPOS.forEach((r) => expect(screen.getByText(r.name)).toBeInTheDocument())\n  );\n  expect(screen.queryByText('Loading...')).toBeNull();\n});\n```\n\n## Conclusion\n\nThis comprehensive cheat sheet covers basic to advanced RTL usage—rendering, querying, mocking, custom queries, and integration tests—to help you write robust, maintainable tests.\n"
}